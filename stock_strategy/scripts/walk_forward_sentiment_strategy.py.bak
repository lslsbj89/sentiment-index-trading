#!/usr/bin/env python3
"""
Walk-Forward æƒ…ç»ªæŒ‡æ•°ç­–ç•¥éªŒè¯

è®¾è®¡ï¼š
- è®­ç»ƒæœŸï¼š4å¹´
- æµ‹è¯•æœŸï¼š1å¹´
- æ­¥é•¿ï¼š1å¹´
- é¿å…æœªæ¥ä¿¡æ¯æ³„éœ²ï¼ŒçœŸå®éªŒè¯ç­–ç•¥ç¨³å¥æ€§
"""

import sys
import os
sys.path.insert(0, os.path.join(os.path.dirname(__file__), '..', '..', 'src'))

import pandas as pd
import numpy as np
import psycopg2
from datetime import datetime
from itertools import product
from data_loader import DataLoader

db_config = {
    'host': 'localhost',
    'database': 'crypto_fear_greed_2',
    'user': 'sc2025',
    'password': '',
    'port': 5432
}

def load_sentiment_index(symbol, smoothing=3):
    """åŠ è½½æƒ…ç»ªæŒ‡æ•°"""
    conn = psycopg2.connect(**db_config)
    table_name = "fear_greed_index_s3" if smoothing == 3 else "fear_greed_index"
    query = f"""
        SELECT date, smoothed_index
        FROM {table_name}
        WHERE symbol = 'GOOGL'
          AND date >= '2012-01-01'
          AND date <= '2020-12-31'
        ORDER BY date
    """
    df = pd.read_sql(query, conn, parse_dates=['date'])
    conn.close()
    df['date'] = pd.to_datetime(df['date'], utc=True)
    df.set_index('date', inplace=True)
    return df

def backtest_strategy(prices, sentiment, buy_threshold, sell_and_threshold, sell_or_threshold):
    """
    å›æµ‹ç­–ç•¥ï¼ˆå·²ç§»é™¤60å¤©è¶…æ—¶é™åˆ¶ï¼‰

    å–å‡ºæ¡ä»¶ï¼š
    1. ORå–å‡ºï¼šæŒ‡æ•° > or_threshold
    2. ANDå–å‡ºï¼šæŒ‡æ•° > and_threshold ä¸” ä»·æ ¼ < MA50
    3. æœŸæœ«å¹³ä»“ï¼šå›æµ‹ç»“æŸä»æœ‰æŒä»“
    """
    df = prices.copy()
    df['idx'] = sentiment['smoothed_index']
    df['MA50'] = df['Close'].rolling(50).mean()
    df = df.dropna()

    if len(df) < 100:
        return None

    cash = 100000
    position = 0
    portfolio_values = []
    trades = []

    entry_price = 0
    entry_date = None

    for i in range(len(df)):
        current_date = df.index[i]
        current_price = df['Close'].iloc[i]
        current_idx = df['idx'].iloc[i]
        current_ma50 = df['MA50'].iloc[i]

        # ä¹°å…¥é€»è¾‘
        if position == 0 and current_idx < buy_threshold:
            available = cash * 0.8
            shares = int(available / (current_price * 1.002))
            if shares > 0:
                cost = shares * current_price * 1.002
                cash -= cost
                position = shares
                entry_price = current_price * 1.002
                entry_date = current_date

        # å–å‡ºé€»è¾‘ï¼ˆç§»é™¤60å¤©é™åˆ¶ï¼‰
        elif position > 0:
            sell_signal = False
            exit_reason = None

            # æ¡ä»¶1: ORå–å‡º
            if current_idx > sell_or_threshold:
                sell_signal = True
                exit_reason = 'OR'
            # æ¡ä»¶2: ANDå–å‡º
            elif current_idx > sell_and_threshold and current_price < current_ma50:
                sell_signal = True
                exit_reason = 'AND'

            if sell_signal:
                revenue = position * current_price * 0.998
                cash += revenue

                profit = revenue - (position * entry_price)
                profit_pct = (profit / (position * entry_price)) * 100

                trades.append({
                    'entry_date': entry_date,
                    'exit_date': current_date,
                    'profit': profit,
                    'profit_pct': profit_pct,
                    'exit_reason': exit_reason
                })

                position = 0

        total_value = cash + position * current_price
        portfolio_values.append(total_value)

    # æœŸæœ«å¼ºåˆ¶å¹³ä»“
    if position > 0:
        final_price = df['Close'].iloc[-1]
        revenue = position * final_price * 0.998
        cash += revenue

        profit = revenue - (position * entry_price)
        profit_pct = (profit / (position * entry_price)) * 100

        trades.append({
            'entry_date': entry_date,
            'exit_date': df.index[-1],
            'profit': profit,
            'profit_pct': profit_pct,
            'exit_reason': 'EOD'
        })

    final_value = cash
    total_return = (final_value - 100000) / 100000 * 100

    # è®¡ç®—æŒ‡æ ‡
    portfolio_series = pd.Series(portfolio_values)
    cummax = portfolio_series.cummax()
    drawdown = (portfolio_series - cummax) / cummax * 100
    max_drawdown = drawdown.min()

    returns = portfolio_series.pct_change().dropna()
    sharpe_ratio = (returns.mean() / returns.std()) * np.sqrt(252) if returns.std() > 0 else 0

    # äº¤æ˜“ç»Ÿè®¡
    if trades:
        win_trades = [t for t in trades if t['profit'] > 0]
        win_rate = len(win_trades) / len(trades) if trades else 0
    else:
        win_rate = 0

    return {
        'total_return': total_return,
        'max_drawdown': max_drawdown,
        'sharpe_ratio': sharpe_ratio,
        'win_rate': win_rate,
        'num_trades': len(trades),
        'final_value': final_value
    }

def score_function(result):
    """
    è¯„åˆ†å‡½æ•°ï¼ˆç»¼åˆç‰ˆï¼‰

    ç»„åˆè€ƒè™‘ï¼š
    - Sharpeç‡ï¼ˆ40%æƒé‡ï¼‰
    - æœ€å¤§å›æ’¤ï¼ˆ30%æƒé‡ï¼‰
    - èƒœç‡ï¼ˆ20%æƒé‡ï¼‰
    - äº¤æ˜“é¢‘ç‡ï¼ˆ10%æƒé‡ï¼Œé¿å…è¿‡åº¦äº¤æ˜“ï¼‰
    """
    if result is None:
        return -9999

    sharpe = result['sharpe_ratio']
    max_dd = abs(result['max_drawdown'])
    win_rate = result['win_rate']
    num_trades = result['num_trades']

    # å½’ä¸€åŒ–äº¤æ˜“æ¬¡æ•°ï¼ˆå‡è®¾ç†æƒ³äº¤æ˜“æ¬¡æ•°ä¸º10-20æ¬¡/å¹´ï¼‰
    trade_score = 1.0
    if num_trades < 5:
        trade_score = 0.5  # äº¤æ˜“å¤ªå°‘
    elif num_trades > 50:
        trade_score = 0.5  # äº¤æ˜“å¤ªå¤š

    # ç»¼åˆè¯„åˆ†
    score = (
        0.4 * sharpe +
        0.3 * (1 - max_dd / 100) +
        0.2 * win_rate +
        0.1 * trade_score
    )

    return score

def grid_search_train(prices, sentiment, param_space):
    """
    åœ¨è®­ç»ƒæœŸè¿›è¡Œç½‘æ ¼æœç´¢

    è¿”å›ï¼šæ‰€æœ‰å‚æ•°ç»„åˆçš„è¯„åˆ†
    """
    results = []

    total_combinations = (
        len(param_space['buy']) *
        len(param_space['and']) *
        len(param_space['or'])
    )

    count = 0
    for buy, and_t, or_t in product(
        param_space['buy'],
        param_space['and'],
        param_space['or']
    ):
        count += 1
        if count % 10 == 0:
            print(f"  æœç´¢è¿›åº¦: {count}/{total_combinations}", end='\r')

        try:
            result = backtest_strategy(prices, sentiment, buy, and_t, or_t)
            if result:
                score = score_function(result)
                results.append({
                    'buy': buy,
                    'and': and_t,
                    'or': or_t,
                    'score': score,
                    **result
                })
        except:
            pass

    print(f"  æœç´¢å®Œæˆ: {len(results)} ä¸ªæœ‰æ•ˆç»“æœ")

    return pd.DataFrame(results)

def walk_forward_analysis(symbol, smoothing=3):
    """
    Walk-Forwardåˆ†æä¸»å‡½æ•°

    çª—å£è®¾è®¡ï¼š
    - è®­ç»ƒæœŸï¼š4å¹´
    - æµ‹è¯•æœŸï¼š1å¹´
    - æ­¥é•¿ï¼š1å¹´
    """
    print(f"\n{'='*80}")
    print(f"Walk-Forward åˆ†æ: {symbol} (Smoothing={smoothing})")
    print(f"{'='*80}\n")

    # åŠ è½½æ•°æ®
    print("åŠ è½½æ•°æ®...")
    loader = DataLoader(db_config)
    prices = loader.load_ohlcv(symbol, '2012-01-01', '2020-12-31')
    sentiment = load_sentiment_index(symbol, smoothing)

    # å¯¹é½æ•°æ®
    common_dates = prices.index.intersection(sentiment.index)
    prices = prices.loc[common_dates]
    sentiment = sentiment.loc[common_dates]

    # å®šä¹‰çª—å£ï¼ˆ2016-2020æµ‹è¯•æœŸï¼‰
    windows = [
        {'name': 'Window1', 'train': ('2012-01-01', '2015-12-31'), 'test': ('2016-01-01', '2016-12-31')},
        {'name': 'Window2', 'train': ('2013-01-01', '2016-12-31'), 'test': ('2017-01-01', '2017-12-31')},
        {'name': 'Window3', 'train': ('2014-01-01', '2017-12-31'), 'test': ('2018-01-01', '2018-12-31')},
        {'name': 'Window4', 'train': ('2015-01-01', '2018-12-31'), 'test': ('2019-01-01', '2019-12-31')},
        {'name': 'Window5', 'train': ('2016-01-01', '2019-12-31'), 'test': ('2020-01-01', '2020-12-31')},
    ]

    # å‚æ•°æœç´¢ç©ºé—´ï¼ˆæ ¹æ®smoothingè°ƒæ•´ï¼‰
    if smoothing == 3:
        param_space = {
            'buy': [-15, -10, -5, 0, 5, 10],   # 6ä¸ªå€¼ï¼ˆç§»é™¤-20ï¼‰
            'and': [10, 15, 20, 25, 30],       # 5ä¸ªå€¼ï¼ˆç§»é™¤0, 5ï¼‰
            'or': [40, 50, 60, 70]             # 4ä¸ªå€¼ï¼ˆç§»é™¤30ï¼‰
        }
    else:  # smoothing == 5
        param_space = {
            'buy': [-15, -10, -5, 0, 5, 10],   # 6ä¸ªå€¼ï¼ˆç§»é™¤-20ï¼‰
            'and': [10, 15, 20, 25, 30],       # 5ä¸ªå€¼ï¼ˆç§»é™¤0, 5ï¼‰
            'or': [35, 40, 45, 50, 60]         # 5ä¸ªå€¼ï¼ˆç§»é™¤30, 70ï¼‰
        }
        # æ€»å…± 6Ã—5Ã—5 = 150 ä¸ªç»„åˆ

    # Walk-Forwardå¾ªç¯
    wf_results = []
    all_train_params = []

    for window in windows:
        print(f"\n{'='*70}")
        print(f"{window['name']}: è®­ç»ƒ{window['train'][0][:4]}-{window['train'][1][:4]} â†’ æµ‹è¯•{window['test'][0][:4]}")
        print(f"{'='*70}")

        # è®­ç»ƒæœŸæ•°æ®
        train_prices = prices.loc[window['train'][0]:window['train'][1]]
        train_sentiment = sentiment.loc[window['train'][0]:window['train'][1]]

        print(f"\nğŸ“Š è®­ç»ƒæœŸç½‘æ ¼æœç´¢...")
        train_results = grid_search_train(train_prices, train_sentiment, param_space)

        # æ‰¾åˆ°æœ€ä¼˜å‚æ•°
        best_train = train_results.sort_values('score', ascending=False).iloc[0]
        best_params = {
            'buy': best_train['buy'],
            'and': best_train['and'],
            'or': best_train['or']
        }
        all_train_params.append(best_params)

        print(f"\nâœ… è®­ç»ƒæœŸæœ€ä¼˜å‚æ•°:")
        print(f"   buy < {best_params['buy']}, and > {best_params['and']}, or > {best_params['or']}")
        print(f"   è®­ç»ƒæœŸSharpe: {best_train['sharpe_ratio']:.4f}")
        print(f"   è®­ç»ƒæœŸæ”¶ç›Š: {best_train['total_return']:.2f}%")
        print(f"   è¯„åˆ†: {best_train['score']:.4f}")

        # æµ‹è¯•æœŸæ•°æ®
        test_prices = prices.loc[window['test'][0]:window['test'][1]]
        test_sentiment = sentiment.loc[window['test'][0]:window['test'][1]]

        print(f"\nğŸ“ˆ æµ‹è¯•æœŸå›æµ‹ï¼ˆç”¨è®­ç»ƒæœŸæœ€ä¼˜å‚æ•°ï¼‰...")
        test_result = backtest_strategy(
            test_prices, test_sentiment,
            best_params['buy'], best_params['and'], best_params['or']
        )

        if test_result:
            print(f"\nâœ… æµ‹è¯•æœŸç»“æœ:")
            print(f"   æ”¶ç›Š: {test_result['total_return']:.2f}%")
            print(f"   Sharpe: {test_result['sharpe_ratio']:.4f}")
            print(f"   æœ€å¤§å›æ’¤: {test_result['max_drawdown']:.2f}%")
            print(f"   èƒœç‡: {test_result['win_rate']*100:.1f}%")
            print(f"   äº¤æ˜“æ¬¡æ•°: {test_result['num_trades']}")

            # åˆ¤æ–­æ˜¯å¦ç›ˆåˆ©
            is_profitable = test_result['total_return'] > 0
            print(f"   çŠ¶æ€: {'âœ… ç›ˆåˆ©' if is_profitable else 'âŒ äºæŸ'}")

            wf_results.append({
                'window': window['name'],
                'train_period': f"{window['train'][0][:4]}-{window['train'][1][:4]}",
                'test_period': window['test'][0][:4],
                'train_sharpe': best_train['sharpe_ratio'],
                'train_return': best_train['total_return'],
                'test_return': test_result['total_return'],
                'test_sharpe': test_result['sharpe_ratio'],
                'test_max_dd': test_result['max_drawdown'],
                'test_win_rate': test_result['win_rate'],
                'test_trades': test_result['num_trades'],
                'is_profitable': is_profitable,
                **best_params
            })
        else:
            print("âŒ æµ‹è¯•æœŸæ•°æ®ä¸è¶³")

    return pd.DataFrame(wf_results), all_train_params, param_space

def analyze_parameter_robustness(all_params):
    """åˆ†æå‚æ•°ç¨³å¥æ€§"""
    print(f"\n{'='*80}")
    print("å‚æ•°ç¨³å¥æ€§åˆ†æ")
    print(f"{'='*80}\n")

    df_params = pd.DataFrame(all_params)

    print("ğŸ“Š å„å‚æ•°ç»Ÿè®¡:")
    print(f"\nbuyé˜ˆå€¼:")
    print(f"  å‡å€¼: {df_params['buy'].mean():.1f}")
    print(f"  æ ‡å‡†å·®: {df_params['buy'].std():.1f}")
    print(f"  èŒƒå›´: [{df_params['buy'].min()}, {df_params['buy'].max()}]")
    print(f"  åˆ†å¸ƒ: {df_params['buy'].value_counts().sort_index().to_dict()}")

    print(f"\nandé˜ˆå€¼:")
    print(f"  å‡å€¼: {df_params['and'].mean():.1f}")
    print(f"  æ ‡å‡†å·®: {df_params['and'].std():.1f}")
    print(f"  èŒƒå›´: [{df_params['and'].min()}, {df_params['and'].max()}]")
    print(f"  åˆ†å¸ƒ: {df_params['and'].value_counts().sort_index().to_dict()}")

    print(f"\noré˜ˆå€¼:")
    print(f"  å‡å€¼: {df_params['or'].mean():.1f}")
    print(f"  æ ‡å‡†å·®: {df_params['or'].std():.1f}")
    print(f"  èŒƒå›´: [{df_params['or'].min()}, {df_params['or'].max()}]")
    print(f"  åˆ†å¸ƒ: {df_params['or'].value_counts().sort_index().to_dict()}")

    # è®¡ç®—ç¨³å¥åŒºï¼ˆå‡å€¼Â±1å€æ ‡å‡†å·®ï¼‰
    robust_zone = {
        'buy': (df_params['buy'].mean() - df_params['buy'].std(),
                df_params['buy'].mean() + df_params['buy'].std()),
        'and': (df_params['and'].mean() - df_params['and'].std(),
                df_params['and'].mean() + df_params['and'].std()),
        'or': (df_params['or'].mean() - df_params['or'].std(),
               df_params['or'].mean() + df_params['or'].std())
    }

    print(f"\nğŸ“ ç¨³å¥åŒºï¼ˆå‡å€¼Â±1Ïƒï¼‰:")
    print(f"  buy: [{robust_zone['buy'][0]:.1f}, {robust_zone['buy'][1]:.1f}]")
    print(f"  and: [{robust_zone['and'][0]:.1f}, {robust_zone['and'][1]:.1f}]")
    print(f"  or: [{robust_zone['or'][0]:.1f}, {robust_zone['or'][1]:.1f}]")

    # æ¨èå‚æ•°ï¼ˆå››èˆäº”å…¥åˆ°æœ€è¿‘çš„æœç´¢ç½‘æ ¼ç‚¹ï¼‰
    recommended = {
        'buy': round(df_params['buy'].mean()),
        'and': round(df_params['and'].mean() / 5) * 5,  # å››èˆäº”å…¥åˆ°5çš„å€æ•°
        'or': round(df_params['or'].mean() / 5) * 5
    }

    print(f"\nğŸ¯ æ¨èå®ç›˜å‚æ•°ï¼ˆç¨³å¥åŒºä¸­å¿ƒï¼‰:")
    print(f"  buy < {recommended['buy']}")
    print(f"  and > {recommended['and']}")
    print(f"  or > {recommended['or']}")

    return robust_zone, recommended

def evaluate_strategy(wf_results):
    """ç­–ç•¥æœ€ç»ˆè¯„çº§"""
    print(f"\n{'='*80}")
    print("ç­–ç•¥æœ€ç»ˆè¯„çº§")
    print(f"{'='*80}\n")

    # ç›ˆåˆ©çª—å£ç‡
    profitable_rate = wf_results['is_profitable'].sum() / len(wf_results) * 100

    # å¹³å‡æµ‹è¯•æŒ‡æ ‡
    avg_test_return = wf_results['test_return'].mean()
    avg_test_sharpe = wf_results['test_sharpe'].mean()
    avg_test_dd = wf_results['test_max_dd'].mean()
    avg_test_winrate = wf_results['test_win_rate'].mean()

    print(f"ğŸ“Š Walk-Forward æ€»ä½“è¡¨ç°:")
    print(f"  çª—å£æ•°: {len(wf_results)}")
    print(f"  ç›ˆåˆ©çª—å£ç‡: {profitable_rate:.1f}% ({wf_results['is_profitable'].sum()}/{len(wf_results)})")
    print(f"  å¹³å‡æµ‹è¯•æ”¶ç›Š: {avg_test_return:.2f}%")
    print(f"  å¹³å‡æµ‹è¯•Sharpe: {avg_test_sharpe:.4f}")
    print(f"  å¹³å‡æœ€å¤§å›æ’¤: {avg_test_dd:.2f}%")
    print(f"  å¹³å‡èƒœç‡: {avg_test_winrate*100:.1f}%")

    # è¯„çº§é€»è¾‘
    print(f"\nğŸ¯ ç­–ç•¥è¯„çº§:")

    grade_points = 0

    # ç›ˆåˆ©çª—å£ç‡ï¼ˆ40åˆ†ï¼‰
    if profitable_rate >= 80:
        grade_points += 40
        print(f"  âœ… ç›ˆåˆ©çª—å£ç‡ {profitable_rate:.1f}% (â‰¥80%): +40åˆ†")
    elif profitable_rate >= 60:
        grade_points += 30
        print(f"  âš ï¸ ç›ˆåˆ©çª—å£ç‡ {profitable_rate:.1f}% (60-80%): +30åˆ†")
    else:
        grade_points += 10
        print(f"  âŒ ç›ˆåˆ©çª—å£ç‡ {profitable_rate:.1f}% (<60%): +10åˆ†")

    # å¹³å‡Sharpeï¼ˆ30åˆ†ï¼‰
    if avg_test_sharpe >= 1.0:
        grade_points += 30
        print(f"  âœ… å¹³å‡Sharpe {avg_test_sharpe:.2f} (â‰¥1.0): +30åˆ†")
    elif avg_test_sharpe >= 0.8:
        grade_points += 20
        print(f"  âš ï¸ å¹³å‡Sharpe {avg_test_sharpe:.2f} (0.8-1.0): +20åˆ†")
    else:
        grade_points += 10
        print(f"  âŒ å¹³å‡Sharpe {avg_test_sharpe:.2f} (<0.8): +10åˆ†")

    # å¹³å‡å›æ’¤ï¼ˆ20åˆ†ï¼‰
    if abs(avg_test_dd) <= 15:
        grade_points += 20
        print(f"  âœ… å¹³å‡å›æ’¤ {avg_test_dd:.1f}% (â‰¤15%): +20åˆ†")
    elif abs(avg_test_dd) <= 25:
        grade_points += 10
        print(f"  âš ï¸ å¹³å‡å›æ’¤ {avg_test_dd:.1f}% (15-25%): +10åˆ†")
    else:
        grade_points += 0
        print(f"  âŒ å¹³å‡å›æ’¤ {avg_test_dd:.1f}% (>25%): +0åˆ†")

    # å¹³å‡æ”¶ç›Šï¼ˆ10åˆ†ï¼‰
    if avg_test_return >= 20:
        grade_points += 10
        print(f"  âœ… å¹³å‡æ”¶ç›Š {avg_test_return:.1f}% (â‰¥20%): +10åˆ†")
    elif avg_test_return >= 10:
        grade_points += 5
        print(f"  âš ï¸ å¹³å‡æ”¶ç›Š {avg_test_return:.1f}% (10-20%): +5åˆ†")
    else:
        grade_points += 0
        print(f"  âŒ å¹³å‡æ”¶ç›Š {avg_test_return:.1f}% (<10%): +0åˆ†")

    print(f"\næ€»åˆ†: {grade_points}/100")

    # æœ€ç»ˆè¯„çº§
    if grade_points >= 85:
        grade = "ğŸŸ¢ Açº§ - å¯å®ç›˜"
        recommendation = "ç­–ç•¥è¡¨ç°ä¼˜ç§€ï¼Œå‚æ•°ç¨³å¥ï¼Œå»ºè®®å®ç›˜éƒ¨ç½²"
    elif grade_points >= 70:
        grade = "ğŸŸ¡ Bçº§ - è§‚å¯Ÿæ± "
        recommendation = "ç­–ç•¥åŸºæœ¬åˆæ ¼ï¼Œå»ºè®®å°ä»“ä½æµ‹è¯•æˆ–ç»§ç»­ä¼˜åŒ–"
    else:
        grade = "ğŸ”´ Cçº§ - æ·˜æ±°"
        recommendation = "ç­–ç•¥è¡¨ç°ä¸ä½³ï¼Œä¸å»ºè®®å®ç›˜ï¼Œéœ€é‡æ–°è®¾è®¡"

    print(f"\næœ€ç»ˆè¯„çº§: {grade}")
    print(f"å»ºè®®: {recommendation}")

    return grade, grade_points

def main():
    # æµ‹è¯•å‚æ•°
    symbol = 'GOOGL'
    smoothing = 3

    # è¿è¡ŒWalk-Forwardåˆ†æ
    wf_results, all_params, param_space = walk_forward_analysis(symbol, smoothing)

    # æ˜¾ç¤ºæ‰€æœ‰çª—å£ç»“æœ
    print(f"\n{'='*80}")
    print("æ‰€æœ‰çª—å£è¯¦ç»†ç»“æœ")
    print(f"{'='*80}\n")
    print(wf_results.to_string(index=False))

    # å‚æ•°ç¨³å¥æ€§åˆ†æ
    robust_zone, recommended = analyze_parameter_robustness(all_params)

    # ç­–ç•¥è¯„çº§
    grade, points = evaluate_strategy(wf_results)

    # ä¿å­˜ç»“æœ
    timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')

    # ä¿å­˜çª—å£ç»“æœ
    filename_wf = f'../results/walk_forward_{symbol}_s{smoothing}_{timestamp}.csv'
    wf_results.to_csv(filename_wf, index=False)
    print(f"\nâœ… Walk-Forwardç»“æœå·²ä¿å­˜: {filename_wf}")

    # ä¿å­˜å‚æ•°åˆ†å¸ƒ
    filename_params = f'../results/walk_forward_params_{symbol}_s{smoothing}_{timestamp}.csv'
    pd.DataFrame(all_params).to_csv(filename_params, index=False)
    print(f"âœ… å‚æ•°åˆ†å¸ƒå·²ä¿å­˜: {filename_params}")

    print(f"\n{'='*80}")
    print("âœ… Walk-Forwardåˆ†æå®Œæˆï¼")
    print(f"{'='*80}\n")

if __name__ == "__main__":
    main()
